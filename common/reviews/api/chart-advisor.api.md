## API Report File for "@antv/chart-advisor"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { AllSubspaceDatasetOptions } from '@antv/dw-transform';
import { ChartID } from '@antv/knowledge';
import * as DWAnalyzer from '@antv/dw-analyzer';
import * as G2Plot from '@antv/g2plot';
import { LevelOfMeasurement } from '@antv/knowledge';
import { Purpose } from '@antv/knowledge';
import { RowData } from '@antv/dw-transform';

// @beta
export interface Advice {
    // (undocumented)
    score: number;
    // (undocumented)
    spec: Specification | null;
    // (undocumented)
    type: ChartID;
}

// @beta (undocumented)
export function adviceToLibConfig(advice: Advice, libraryName?: 'G2' | 'G2Plot'): G2PlotConfig | null;

// @public (undocumented)
export interface AdvisorOptions {
    chartRuleConfigs?: ChartRuleConfigMap;
    description?: string;
    preferences?: Preferences;
    purpose?: string;
    refine?: boolean;
    title?: string;
}

// @beta (undocumented)
export type Aggregation = 'count';

// @public
export function autoChart(container: HTMLElement | string, data: any[] | Promise<any[]>, options?: AutoChartOptions): Promise<void>;

// @public
export interface AutoChartOptions {
    chartRuleConfigs?: ChartRuleConfigMap;
    config?: G2PlotConfig;
    description?: string;
    development?: boolean;
    feedback?: (container: HTMLDivElement) => void;
    fields?: string[];
    noDataContent?: (container: HTMLDivElement) => void;
    preferences?: Preferences;
    purpose?: string;
    refine?: boolean;
    theme?: string;
    title?: string;
    toolbar?: boolean;
}

// @beta (undocumented)
export type ChartLibrary = 'G2Plot' | 'G2';

// @public (undocumented)
export interface ChartRuleConfig {
    // (undocumented)
    limit?: number;
    // (undocumented)
    off?: boolean;
    // (undocumented)
    weight?: number;
}

// @public (undocumented)
export type ChartRuleConfigMap = {
    [K in ChartRuleID]?: ChartRuleConfig;
};

// @public (undocumented)
export type ChartRuleID = 'data-check' | 'data-field-qty' | 'no-redundant-field' | 'purpose-check' | 'series-qty-limit' | 'bar-series-qty' | 'line-field-time-ordinal' | 'landscape-or-portrait' | 'diff-pie-sector' | 'nominal-enum-combinatorial' | 'limit-series';

// @public (undocumented)
export const ChartRules: Rule[];

// @beta
export type DataProperty = (DWAnalyzer.NumberFieldInfo & {
    name: string;
    levelOfMeasurements: LevelOfMeasurement[];
}) | (DWAnalyzer.DateFieldInfo & {
    name: string;
    levelOfMeasurements: LevelOfMeasurement[];
}) | (DWAnalyzer.StringFieldInfo & {
    name: string;
    levelOfMeasurements: LevelOfMeasurement[];
});

// @public (undocumented)
export interface DataProps {
    // (undocumented)
    count?: number;
    // (undocumented)
    distinct?: number;
    // (undocumented)
    levelOfMeasurements: LevelOfMeasurement[];
    // (undocumented)
    maximum?: any;
    // (undocumented)
    minimum?: any;
    // (undocumented)
    missing: number;
    // (undocumented)
    name: string;
    // (undocumented)
    samples?: any[];
    // (undocumented)
    sum?: number;
}

// @beta (undocumented)
export function dataPropsToAdvices(dataProps: DataProperty[], options?: AdvisorOptions, showLog?: boolean): Advice[];

// @beta
export function dataToDataProps(data: any[]): DataProperty[];

// @beta (undocumented)
export function dataToSpecs(data: any[], options?: AdvisorOptions, showLog?: boolean): Advice[];

// @beta (undocumented)
export type EncodingKey = 'x' | 'y' | 'x2' | 'y2' | 'column' | 'row' | 'longitude' | 'latitude' | 'longitude2' | 'latitude2' | 'theta' | 'theta2' | 'radius' | 'radius2' | 'color' | 'fill' | 'stroke' | 'opacity' | 'fillOpacity' | 'strokeOpacity' | 'strokeWidth' | 'strokeDash' | 'size' | 'angle' | 'shape' | 'detail' | 'text' | 'order';

// @beta (undocumented)
export type EncodingType = 'quantitative' | 'temporal' | 'ordinal' | 'nominal' | 'geojson';

// @beta (undocumented)
export const G2PLOT_TYPE_MAPPING: Partial<Record<ChartID, G2PlotChartType>>;

// @public (undocumented)
export type G2PlotChartType = 'Line' | 'Area' | 'Column' | 'Bar' | 'Pie' | 'Rose' | 'Scatter' | 'Histogram' | 'Heatmap';

// @public (undocumented)
export interface G2PlotConfig {
    // (undocumented)
    configs: Record<string, any>;
    // (undocumented)
    type: G2PlotChartType;
}

// @beta
export function g2plotRender(container: string | HTMLElement, data: any, libConfigs: G2PlotConfig): G2Plot.Line | G2Plot.Area | G2Plot.Column | G2Plot.Bar | G2Plot.Pie | G2Plot.Rose | G2Plot.Scatter | G2Plot.Histogram | G2Plot.Heatmap | null;

// @beta
export function g2Render(container: string | HTMLElement, data: any, configs: G2PlotConfig): G2Plot.G2.Chart | undefined;

// @public (undocumented)
export type HardOrSoft = 'HARD' | 'SOFT';

// @public (undocumented)
export interface Info {
    // (undocumented)
    [key: string]: any;
    // (undocumented)
    chartType: ChartID;
    // (undocumented)
    customWeight?: number;
    // (undocumented)
    dataProps: DataProps[];
    // (undocumented)
    preferences?: Preferences;
    // (undocumented)
    purpose?: string;
}

// @beta (undocumented)
export interface Insight {
    // (undocumented)
    description?: string;
    // (undocumented)
    fields: string[];
    // (undocumented)
    insightProps?: InsightProps;
    // (undocumented)
    present?: {
        fields?: string[];
        type?: ChartID;
        encoding?: any;
        purpose?: Purpose[];
        data?: RowData[];
        configs?: any;
    };
    // (undocumented)
    type: InsightType | 'SomeInsight';
}

// @beta (undocumented)
export const INSIGHT_TYPES: ["Correlation", "Monotonicity", "MajorFactors", "OverallTrends", "CategoryOutliers", "TimeSeriesOutliers", "Seasonality", "ChangePoints"];

// @beta (undocumented)
export interface InsightProps {
    // (undocumented)
    detail?: any;
    // (undocumented)
    dimensions?: string[];
    // (undocumented)
    measures?: string[];
    // (undocumented)
    score?: number;
}

// @beta (undocumented)
export function insightsFromData(data: RowData[]): Promise<Insight[]>;

// @beta (undocumented)
export function insightsFromDataset(data: RowData[], options?: AllSubspaceDatasetOptions): Promise<Insight[]>;

// @beta (undocumented)
export type InsightType = typeof INSIGHT_TYPES[number];

// @beta (undocumented)
export const insightWorkers: Partial<Record<InsightType, Worker>>;

// @beta (undocumented)
export type Mark = 'area' | 'arc' | 'bar' | 'circle' | 'line' | 'point' | 'rect' | 'rule' | 'square' | 'text' | 'tick' | 'rect' | 'geoshape';

// @public
export interface Preferences {
    // (undocumented)
    canvasLayout: 'landscape' | 'portrait';
}

// @public (undocumented)
export class Rule {
    constructor(id: string, hardOrSoft: HardOrSoft, specChartTypes: ChartID[], weight: number, validator: Validator);
    // (undocumented)
    check(args: Info): number;
    // (undocumented)
    get hardOrSoft(): HardOrSoft;
    // (undocumented)
    get id(): string;
    // (undocumented)
    get specChartTypes(): ChartID[];
    // (undocumented)
    toString(): string;
    // (undocumented)
    get weight(): number;
    }

// @beta (undocumented)
export interface SingleViewSpec {
    // (undocumented)
    encoding: VegaLiteEncodeingSpecification;
    // (undocumented)
    mark: {
        type: Mark;
        [record: string]: any;
    };
}

// @beta (undocumented)
export type Specification = SingleViewSpec;

// @beta (undocumented)
export function specRender(container: string | HTMLElement, data: any[], spec: Advice, libraryName?: 'G2' | 'G2Plot'): G2Plot.G2.Chart | G2Plot.Line | G2Plot.Area | G2Plot.Column | G2Plot.Bar | G2Plot.Pie | G2Plot.Rose | G2Plot.Scatter | G2Plot.Histogram | G2Plot.Heatmap | null | undefined;

// @beta (undocumented)
export type StackType = 'zero' | 'center' | 'normalize' | null | boolean;

// @public (undocumented)
export type Validator = (args: Info) => number;

// @beta (undocumented)
export type VegaLiteEncodeingSpecification = Partial<Record<EncodingKey, {
    field?: string;
    type?: EncodingType;
    bin?: boolean;
    aggregate?: Aggregation;
    stack?: StackType;
    scale?: any;
    domain?: any;
    ticks?: any;
}>>;

// @beta (undocumented)
export type VegaLiteSubsetSpec = SingleViewSpec | {
    layer: SingleViewSpec[];
};

// @beta (undocumented)
export type Worker = (data: RowData[]) => Insight[] | Promise<Insight[]>;


```
